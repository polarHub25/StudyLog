## 3장 저장소와 검색 

목적 : 저장소 엔진의 내부에서 수행되는 작업에 대해 개념 이해하기 -> 특정 작업부하 유형에서 좋은 성능을 이끌기 위한 저장소 엔진 조정을 위해 

### 관계형 데이터베이스 
### NoSQL 
#### 로그 구조 계열 저장소 엔진 
#### 페이지 지향 계열소 엔진 

#### 색인 
- 해시 색인
  * 키-값 데이터 index
  * 전략 -> 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시맵을 유지
- 비트캐스크(BitCask)
  * 로그 구조 저장 엔진 중 하나. 쓰기 성능을 극대화한 키-값 저장 방식
  * 리악(Riak)이라는 NoSQL DB에서 기본 저장 엔진으로 사용
  * 해시 맵을 전부 메모리에 유지하므로 사용 가능한 RAM의 모든 키가 저장된다는 조건을 전제로 고성능으로 읽기, 쓰기 보장
  * 각 키의 값이 자주 갱신되는 상황에 적합 ( ex. 키 : 고양이 영상의 URL - 값 : 영상이 재생된 횟수 ) -> 키당 쓰기 수는 많지만 고유키를 보관가능
- But, 파일에 항상 추가만 한다면 디스크 공간 부족 -> 특정 크기의 세그먼트로 로그를 나눈다 -> 컴팩션(compaction) 수행 : 로그에서 중복된 키를 버리고 각 키의 최신 값만 유지하는것

### SS 테이블(Sorted String Table) 
- 정렬된 문자열 테이블
- 각 키는 각 병합된 세그먼트 파일 내에 한번만 나타나야 함(컴팩션 과정은 이미 이를 보장)

### 레드 블랙 트리 (Red-black tree) 
### AVL 트리 
### 멤테이블 (memtable) 
- DB가 디스크에 데이터를 저장하기 전에 메모리에 유지하는 데이터 구조
- 주로 LSM-Tree(Log-Structured Merge-Tree) 기반 저장 엔진에서 사용
- 쓰기 성능 최적화를 위해 데이터를 디스크 대신 메모리에 먼저 저장
### 루씬(Lucene)
- 용어 사전을 저장
- 검색 질의가 들어오면 단어가 언급된 모든 문서를 찾음  ( 키 : 단어 - 값 : 단어를 포함한 모든 문서의 ID 목록 )
### 블룸 필터(Bloom filter) 
- 특정 값이 존재 하지 않는다는 것을 빠르게 확인할 수 있도록 설계된 필터
- DB에 존재하지 않음을 알려주므로 불필요한 디스크 읽기를 많이 절약 가능 
### 레벨 DB / 룩스 DB
- 둘다 LSM-Tree 기반의 키-값 저장 엔진
- 쓰기 성능이 뛰어나고 대규모 데이터 저장에 적합
- 레벨 DB
  * 구글에서 개발한 키-값 저장소 엔진
  * 단일 프로세스에서 사용하기에 적합
  * 단일 저장소만 지원 -> 분산 환경에서는 적합하지 않음
- 룩스 DB
  * 메타에서 레벨 DB를 기반으로 성능 개선하여 개발
  * 분산 시스템에서도 사용 가능 
### B 트리 
- DB와 파일 시스템에서 검색, 삽입, 삭제 연산을 제공하는 트리 구조
- 디스크 I/O 성능 최적화하기 위해 설계
- 관계형 DB의 인덱스 구조로 많이 사용 
### 쓰기전 로그 ( write-ahead-log, WAL) (재실행 로그, redo log)
- 데이터 구조를 추가해 B트리를 구현 -> WAL는 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경사항을 기록하는 추가 전용 파일 
### 래치(latch) 
- 동시성 제어 -> 트리의 데이터 구조를 보호
### LSM Tree
- B 트리보다 쓰기 처리량을 높게 유지 가능 -> LSM트리가 상대적으로 쓰기 증폭이 낮고 트리에서 여러 페이지를 순차적으로 컴팩션된 ss 테이블 파일에 쓰기 때문
- 쉽게 설명하자면, 기존 데이터를 변경하는게 아니라 새로운 파일을 계속 추가하는 방식이라 B 트리보다 쓰기 증폭이 적음 
### 쓰기 증폭 (write amplification)
### 보조 색인(secondary index) 
### 힙 파일(heap file)
### 클러스터드 색인(clustered index)
- index 안에 모든 로우 데이터를 저장
- 데이터가 정렬된 상태로 저장되는 인덱스 구조
### 비클러스터드 색인 (일반 index) 
- index 안에 데이터의 참조만 저장
### 커버링 색인(covering index) / index with included column 
- 클러스터디 색인과 비클러스터 색인 사이의 절충안 
### 결합 색인(concatenated index) 
- 하나의 컬럼에 다른 컬럼을 추가하는 방식 ( 하나의 키가 여러필드를 단순히 결합 ) 
### 퍼지 검색 기술..? 
- 철자가 틀리거나 비슷한 단어를 검색할 때도 유사한 결과를 찾아주는 검색 기술
- 구글 검색, 넷플릭스 추천 시스템 등 ( 검색 오타 자동 수정, 비슷한 제목의 영화 추천 등 ) 
### 인메모리 데이터베이스 
### 맴캐시트(Memcached) 
- 메모리 기반의 분산 캐시 시스템. 자주 조회되는 데이터를 메모리에 저장하여 빠르게 제공하는 것 
### 안티캐싱(anti-caching)
### OLTP(Online transaction processing) 
- index를 사용해 일부 키에 대한 적은 수의 레코드를 찾고, 레코드는 사용자 입력을 기반으로 삽입되거나 갱신. (대화식 애플리케이션)
- 로우 지향 방식으로 데이터 배치
### OLAP (Online analytic processing) 
- 분석가가 작성하며 경영진이 더 나은 결정을 하게끔 돕는 보고서 제공 -> 이럴 때 사용하는 db 사용 패턴을 OLAP 
### 데이터웨어 하우스 
- 분석가들이 OLTP 작업에 영향을 주지않고 마음껏 질의할 수 있는 개별 DB
- 데이터는 OLTP DB에서 (주기적인 데이터 덤프나 갱신 스트림) 추출하고 분석 친화적인 스키마로 변환하여 데이터웨어 하우스에 적재
### 컬럼 지향 저장소
- 모든 값을 하나의 로우에 함께 저장하지 않고, 대신 각 칼럼별로 모든값을 함꼐 저장
### 비트맵 부호화 (bitmap encoding) 
- 데이터중심 애플리케이션 설계 내용중 컬럼 압축에 대해서 이해가 안가는점이 많은 값이 반복해서 나타나서 데이터 압축을 하게되면, 특히 칼럼 압축은 칼럼지향 저장소 배치에 쓰인다고 하는데 그렇다면 테이블에 각 로우에 대해서 데이터가 뒤죽박죽 되는거 아닌가..?
- > 컬럼 압축은 OLAP에 최적화 되었고, 행 순서를 유지하지는 않지만 조회시 다시 조립이 가능. 데이터가 뒤섞이는게 아닌 컬럼별로 효율적으로 저장되고 필요순간에 다시 조립되는 방식

### 벡터화 처리 (Vectorized processing) 
### 구체화 뷰 (materialized view) 
- 질의가 자주 사용하는 카운트나 합계함수를 캐시하는것
- 디스크에 기록된 질의 결과의 실제 복사본
- 원본 데이터 변경시에는 구체화 뷰 갱신해야함 
### 컬럼 저장소 / 행 저장소 
- 행 저장소
  * 일반적인 db가 사용하는 방식( oracle, mysql postgresql..)
  * 데이터를 한줄씩 저장하는 방식
  * 쓰기와 트랜잭션 처리에 유리
  * 모든 컬럼이 함께 저장되어 새로운 데이터 추가시 유리
- 컬럼 저장소
  * 데이터를 컬럼 단위로 저장하는 방식
  * 분석 쿼리에 유리
  * 대용량 데이터 분석에 최적화 되어있음
  * ex. google - bigquery / apache - druid 등 








